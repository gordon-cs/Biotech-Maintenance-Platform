-- =========================================================
-- BIOTECH MAINTENANCE PLATFORM
-- Fresh Supabase Database Initialization Script (public schema)
-- Order:
--   1) Enums
--   2) Helper functions (used by RLS policies)
--   3) Tables + constraints
--   4) Indexes
--   5) Enable RLS + Policies
--   6) Storage buckets
-- =========================================================

BEGIN;

-- =========================
-- 1) ENUM TYPES
-- =========================
CREATE TYPE public.payment_status AS ENUM ('unbilled', 'awaiting_payment', 'paid');
CREATE TYPE public.wo_status      AS ENUM ('open', 'claimed', 'completed', 'canceled');
CREATE TYPE public.wo_update_type AS ENUM ('comment', 'status_change');
CREATE TYPE public.wo_urgency     AS ENUM ('low', 'normal', 'high', 'critical');


-- =========================
-- 2) HELPER FUNCTIONS (RLS)
-- =========================
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
DECLARE
  result boolean;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM public.profiles p
    WHERE p.id = auth.uid()
      AND lower(coalesce(p.role, '')) = 'admin'
  )
  INTO result;

  RETURN result;
END;
$function$;

CREATE OR REPLACE FUNCTION public.is_technician()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
DECLARE
  result boolean;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM public.profiles p
    WHERE p.id = auth.uid()
      AND lower(coalesce(p.role, '')) = 'technician'
  )
  INTO result;

  RETURN result;
END;
$function$;

CREATE OR REPLACE FUNCTION public.uid()
RETURNS uuid
LANGUAGE sql
STABLE
AS $function$
  select auth.uid()
$function$;


-- =========================
-- 3) TABLES + CONSTRAINTS
-- =========================

-- Profiles are tied to Supabase Auth users
CREATE TABLE public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role text,
  full_name text,
  phone text,
  email text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.labs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  manager_id uuid REFERENCES public.profiles(id),
  name text NOT NULL,
  address text,
  address2 text,
  city text,
  state text,
  zipcode text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  bill_customer_id text,
  default_initial_fee numeric DEFAULT 0
);

CREATE TABLE public.addresses (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lab_id bigint NOT NULL REFERENCES public.labs(id),
  label text NOT NULL DEFAULT 'Primary'::text,
  line1 text NOT NULL,
  line2 text,
  city text NOT NULL,
  state text NOT NULL,
  zipcode text NOT NULL,
  is_default boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.categories (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  slug text NOT NULL,
  name text NOT NULL,
  active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.technicians (
  id uuid PRIMARY KEY REFERENCES public.profiles(id),
  experience text,
  bio text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  company text,
  bill_vendor_id text,
  verified boolean,
  resume_url text,
  vendor_status text NOT NULL DEFAULT 'not_created'::text,
  vendor_last_synced_at timestamptz
);

CREATE TABLE public.technician_categories (
  tech_id uuid NOT NULL REFERENCES public.technicians(id),
  category_id bigint NOT NULL REFERENCES public.categories(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (tech_id, category_id)
);

-- Note: column name is literally "lab" (bigint FK to labs.id) per your existing schema
CREATE TABLE public.work_orders (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_by uuid NOT NULL REFERENCES public.profiles(id),
  lab bigint NOT NULL REFERENCES public.labs(id),
  title text NOT NULL,
  description text,
  equipment text,
  urgency public.wo_urgency NOT NULL DEFAULT 'normal'::public.wo_urgency,
  status public.wo_status NOT NULL DEFAULT 'open'::public.wo_status,
  date date,
  assigned_to uuid REFERENCES public.technicians(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  category_id bigint REFERENCES public.categories(id),
  address_id bigint REFERENCES public.addresses(id),
  initial_fee numeric DEFAULT 0
);

CREATE TABLE public.work_order_updates (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  work_order_id bigint NOT NULL REFERENCES public.work_orders(id),
  author_id uuid NOT NULL REFERENCES public.profiles(id),
  update_type public.wo_update_type NOT NULL DEFAULT 'comment'::public.wo_update_type,
  new_status public.wo_status,
  body text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE public.invoices (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  work_order_id bigint NOT NULL REFERENCES public.work_orders(id),
  lab_id bigint REFERENCES public.labs(id),
  created_by uuid REFERENCES public.profiles(id),
  total_amount numeric NOT NULL,
  currency text NOT NULL DEFAULT 'USD'::text,
  bill_invoice_id text,
  payment_status public.payment_status NOT NULL DEFAULT 'unbilled'::public.payment_status,
  paid_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  bill_ar_invoice_id text,
  bill_ap_bill_id text,
  invoice_type text DEFAULT 'service'::text,
  technician_payment_status text DEFAULT 'pending'::text,
  technician_paid_at timestamptz
);


-- =========================
-- 4) INDEXES (from your list)
-- =========================

-- addresses
CREATE UNIQUE INDEX idx_addresses_one_default_per_lab ON public.addresses USING btree (lab_id) WHERE is_default;
CREATE INDEX idx_addresses_lab ON public.addresses USING btree (lab_id);

-- categories
CREATE UNIQUE INDEX categories_slug_key ON public.categories USING btree (slug);

-- invoices
CREATE UNIQUE INDEX invoices_work_order_type_unique ON public.invoices USING btree (work_order_id, invoice_type);
CREATE INDEX idx_invoices_tech_payment_status ON public.invoices USING btree (technician_payment_status);

-- labs
CREATE INDEX idx_labs_manager ON public.labs USING btree (manager_id);
CREATE UNIQUE INDEX labs_manager_unique ON public.labs USING btree (manager_id);

-- technician_categories
CREATE INDEX idx_techcat_cat ON public.technician_categories USING btree (category_id);

-- technicians
CREATE UNIQUE INDEX technicians_bill_vendor_id_unique ON public.technicians USING btree (bill_vendor_id)
  WHERE (bill_vendor_id IS NOT NULL);

-- work_order_updates
CREATE INDEX idx_wou_type ON public.work_order_updates USING btree (update_type);
CREATE INDEX idx_wou_wo ON public.work_order_updates USING btree (work_order_id);
CREATE INDEX idx_wou_auth ON public.work_order_updates USING btree (author_id);

-- work_orders
CREATE INDEX idx_wo_assigned ON public.work_orders USING btree (assigned_to);
CREATE INDEX idx_wo_created_by ON public.work_orders USING btree (created_by);
CREATE INDEX idx_wo_lab ON public.work_orders USING btree (lab);
CREATE INDEX idx_work_orders_address ON public.work_orders USING btree (address_id);
CREATE INDEX idx_work_orders_category ON public.work_orders USING btree (category_id);
CREATE INDEX idx_wo_urgency ON public.work_orders USING btree (urgency);
CREATE INDEX idx_wo_status ON public.work_orders USING btree (status);


-- =========================
-- 5) RLS ENABLE + POLICIES
-- =========================
ALTER TABLE public.addresses             ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories            ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoices              ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.labs                  ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles              ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.technician_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.technicians           ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.work_order_updates    ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.work_orders           ENABLE ROW LEVEL SECURITY;

-- ---- addresses
CREATE POLICY addresses_debug_everyone
ON public.addresses FOR SELECT
TO public
USING (true);

CREATE POLICY addresses_delete_admin_or_manager
ON public.addresses FOR DELETE
TO public
USING (
  is_admin()
  OR EXISTS (
    SELECT 1 FROM public.labs l
    WHERE l.id = addresses.lab_id
      AND l.manager_id = uid()
  )
);

CREATE POLICY addresses_insert_admin_or_manager
ON public.addresses FOR INSERT
TO public
WITH CHECK (
  is_admin()
  OR EXISTS (
    SELECT 1 FROM public.labs l
    WHERE l.id = addresses.lab_id
      AND l.manager_id = uid()
  )
);

CREATE POLICY addresses_select_admin_manager_or_tech
ON public.addresses FOR SELECT
TO public
USING (
  is_admin()
  OR EXISTS (
    SELECT 1 FROM public.labs l
    WHERE l.id = addresses.lab_id
      AND l.manager_id = uid()
  )
  OR (
    is_technician()
    AND EXISTS (
      SELECT 1 FROM public.work_orders w
      WHERE w.address_id = addresses.id
        AND (w.status = 'open'::wo_status OR w.assigned_to = uid())
    )
  )
);

CREATE POLICY addresses_update_admin_or_manager
ON public.addresses FOR UPDATE
TO public
USING (
  is_admin()
  OR EXISTS (
    SELECT 1 FROM public.labs l
    WHERE l.id = addresses.lab_id
      AND l.manager_id = uid()
  )
)
WITH CHECK (
  is_admin()
  OR EXISTS (
    SELECT 1 FROM public.labs l
    WHERE l.id = addresses.lab_id
      AND l.manager_id = uid()
  )
);

-- ---- categories
CREATE POLICY categories_admin_write
ON public.categories FOR ALL
TO public
USING (is_admin())
WITH CHECK (is_admin());

CREATE POLICY categories_read_all
ON public.categories FOR SELECT
TO public
USING (true);

-- ---- invoices (as currently configured)
CREATE POLICY "Allow authenticated users to create invoices"
ON public.invoices FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow authenticated users to read invoices"
ON public.invoices FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Allow authenticated users to update invoices"
ON public.invoices FOR UPDATE
TO authenticated
USING (true);

-- ---- labs
CREATE POLICY labs_delete_manager_or_admin
ON public.labs FOR DELETE
TO public
USING (
  manager_id = auth.uid()
  OR EXISTS (
    SELECT 1 FROM public.profiles p
    WHERE p.id = auth.uid()
      AND p.role = 'admin'::text
  )
);

CREATE POLICY labs_insert_manager
ON public.labs FOR INSERT
TO public
WITH CHECK (manager_id = auth.uid());

CREATE POLICY labs_select_manager_or_admin
ON public.labs FOR SELECT
TO public
USING (
  manager_id = auth.uid()
  OR EXISTS (
    SELECT 1 FROM public.profiles p
    WHERE p.id = auth.uid()
      AND p.role = 'admin'::text
  )
);

CREATE POLICY labs_update_manager_or_admin
ON public.labs FOR UPDATE
TO public
USING (
  manager_id = auth.uid()
  OR EXISTS (
    SELECT 1 FROM public.profiles p
    WHERE p.id = auth.uid()
      AND p.role = 'admin'::text
  )
)
WITH CHECK (manager_id = auth.uid());

CREATE POLICY select_labs_technician
ON public.labs FOR SELECT
TO public
USING (is_technician());

-- ---- profiles
CREATE POLICY profiles_admin_delete
ON public.profiles FOR DELETE
TO public
USING (is_admin());

CREATE POLICY profiles_admin_insert
ON public.profiles FOR INSERT
TO public
WITH CHECK (is_admin());

CREATE POLICY profiles_select_self
ON public.profiles FOR SELECT
TO public
USING (auth.uid() = id);

CREATE POLICY profiles_select_self_or_admin
ON public.profiles FOR SELECT
TO public
USING ((id = auth.uid()) OR is_admin());

CREATE POLICY profiles_update_self_or_admin
ON public.profiles FOR UPDATE
TO public
USING ((id = auth.uid()) OR is_admin())
WITH CHECK (
  is_admin()
  OR ((id = auth.uid()) AND (COALESCE(role, ''::text) <> 'admin'::text))
);

-- ---- technician_categories
CREATE POLICY techcat_read_self_or_admin
ON public.technician_categories FOR SELECT
TO public
USING (is_admin() OR (tech_id = uid()));

CREATE POLICY techcat_write_self_or_admin
ON public.technician_categories FOR ALL
TO public
USING (is_admin() OR (tech_id = uid()))
WITH CHECK (is_admin() OR (tech_id = uid()));

-- ---- technicians
CREATE POLICY tech_admin_delete
ON public.technicians FOR DELETE
TO public
USING (is_admin());

CREATE POLICY tech_admin_insert
ON public.technicians FOR INSERT
TO public
WITH CHECK (is_admin());

CREATE POLICY tech_select_self_admin_or_related_manager
ON public.technicians FOR SELECT
TO public
USING (
  is_admin()
  OR (id = uid())
  OR EXISTS (
    SELECT 1
    FROM public.work_orders w
    JOIN public.labs l ON l.id = w.lab
    WHERE w.assigned_to = technicians.id
      AND l.manager_id = uid()
  )
);

CREATE POLICY tech_update_self_or_admin
ON public.technicians FOR UPDATE
TO public
USING ((id = uid()) OR is_admin());

-- ---- work_order_updates
CREATE POLICY wou_delete_author_or_admin
ON public.work_order_updates FOR DELETE
TO public
USING (is_admin() OR (author_id = auth.uid()));

CREATE POLICY wou_insert_roles
ON public.work_order_updates FOR INSERT
TO public
WITH CHECK (
  is_admin()
  OR (
    EXISTS (
      SELECT 1
      FROM public.work_orders w
      JOIN public.labs l ON l.id = w.lab
      WHERE w.id = work_order_updates.work_order_id
        AND (
          w.created_by = auth.uid()
          OR w.assigned_to = auth.uid()
          OR l.manager_id = auth.uid()
        )
    )
    AND (author_id = auth.uid())
  )
);

CREATE POLICY wou_select_inherit_from_work_order
ON public.work_order_updates FOR SELECT
TO public
USING (
  is_admin()
  OR EXISTS (
    SELECT 1
    FROM public.work_orders w
    JOIN public.labs l ON l.id = w.lab
    LEFT JOIN public.profiles p ON p.id = auth.uid()
    WHERE w.id = work_order_updates.work_order_id
      AND (
        w.created_by = auth.uid()
        OR w.assigned_to = auth.uid()
        OR l.manager_id = auth.uid()
        OR (p.role = 'technician'::text AND w.status = 'open'::wo_status)
      )
  )
);

CREATE POLICY wou_update_author_or_admin
ON public.work_order_updates FOR UPDATE
TO public
USING (is_admin() OR (author_id = auth.uid()))
WITH CHECK (is_admin() OR (author_id = auth.uid()));

-- ---- work_orders
CREATE POLICY "Lab managers can delete their orders"
ON public.work_orders FOR DELETE
TO public
USING (
  lab IN (
    SELECT labs.id
    FROM public.labs
    WHERE labs.manager_id = auth.uid()
  )
);

CREATE POLICY work_orders_admin_update
ON public.work_orders FOR UPDATE
TO public
USING (is_admin())
WITH CHECK (is_admin());

CREATE POLICY work_orders_insert_creator
ON public.work_orders FOR INSERT
TO public
WITH CHECK (created_by = auth.uid());

CREATE POLICY work_orders_select_creator_or_lab_manager
ON public.work_orders FOR SELECT
TO public
USING (
  (created_by = auth.uid())
  OR EXISTS (SELECT 1 FROM public.labs l WHERE l.id = work_orders.lab AND l.manager_id = auth.uid())
  OR EXISTS (SELECT 1 FROM public.profiles p WHERE p.id = auth.uid() AND p.role = 'admin'::text)
);

CREATE POLICY work_orders_select_for_technicians
ON public.work_orders FOR SELECT
TO public
USING (
  ((status = 'open'::wo_status) AND (assigned_to IS NULL))
  OR (assigned_to = auth.uid())
);

CREATE POLICY work_orders_select_policy
ON public.work_orders FOR SELECT
TO public
USING (
  EXISTS (SELECT 1 FROM public.labs l WHERE l.id = work_orders.lab AND l.manager_id = auth.uid())
  OR (created_by = auth.uid())
);

CREATE POLICY work_orders_update_claim
ON public.work_orders FOR UPDATE
TO public
USING ((assigned_to IS NULL) OR (assigned_to = auth.uid()))
WITH CHECK (
  ((assigned_to = auth.uid()) AND (status = 'claimed'::wo_status))
  OR ((assigned_to IS NULL) AND (status = 'open'::wo_status))
);

CREATE POLICY work_orders_update_creator
ON public.work_orders FOR UPDATE
TO public
USING (created_by = auth.uid())
WITH CHECK (created_by = auth.uid());

COMMIT;


-- =========================
-- 6) STORAGE BUCKETS
-- =========================
-- Run this separately (storage schema) after the DB schema is created.

INSERT INTO storage.buckets (id, name, public, file_size_limit, avif_autodetection, allowed_mime_types)
VALUES
('resume',  'resume',  false, 5242880, false, NULL),
